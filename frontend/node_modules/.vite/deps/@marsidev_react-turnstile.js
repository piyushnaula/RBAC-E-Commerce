"use client";
import {
  require_jsx_runtime
} from "./chunk-6PXSGDAH.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@marsidev/react-turnstile/dist/index.js
var import_react = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var ae = ({ as: n = "div", ...a }, s) => (0, import_jsx_runtime.jsx)(n, { ...a, ref: s });
var J = (0, import_react2.forwardRef)(ae);
var K = "https://challenges.cloudflare.com/turnstile/v0/api.js";
var b = "cf-turnstile-script";
var U = "cf-turnstile";
var P = "onloadTurnstileCallback";
var M = (n) => !!document.getElementById(n);
var X = ({ render: n = "explicit", onLoadCallbackName: a = P, scriptOptions: { nonce: s = "", defer: e = true, async: m = true, id: v = "", appendTo: g, onError: T, crossOrigin: w = "" } = {} }) => {
  let E = v || b;
  if (M(E)) return;
  let i = document.createElement("script");
  if (i.id = E, i.src = `${K}?onload=${a}&render=${n}`, document.querySelector(`script[src="${i.src}"]`)) return;
  i.defer = !!e, i.async = !!m, s && (i.nonce = s), w && (i.crossOrigin = w), T && (i.onerror = T, delete window[a]), (g === "body" ? document.body : document.getElementsByTagName("head")[0]).appendChild(i);
};
var f = { normal: { width: 300, height: 65 }, compact: { width: 150, height: 140 }, invisible: { width: 0, height: 0, overflow: "hidden" }, flexible: { minWidth: 300, width: "100%", height: 65 }, interactionOnly: { width: "fit-content", height: "auto", display: "flex" } };
function G(n) {
  if (n !== "invisible" && n !== "interactionOnly") return n;
}
function z(n = b) {
  let [a, s] = (0, import_react3.useState)(false);
  return (0, import_react3.useEffect)(() => {
    let e = () => {
      M(n) && s(true);
    }, m = new MutationObserver(e);
    return m.observe(document, { childList: true, subtree: true }), e(), () => {
      m.disconnect();
    };
  }, [n]), a;
}
var _ = "unloaded";
var ee;
var Te = new Promise((n, a) => {
  ee = { resolve: n, reject: a }, _ === "ready" && n(void 0);
});
var we = (n = P) => (_ === "unloaded" && (_ = "loading", window[n] = () => {
  ee.resolve(), _ = "ready", delete window[n];
}), Te);
var Ee = (0, import_react.forwardRef)((n, a) => {
  let { scriptOptions: s, options: e = {}, siteKey: m, onWidgetLoad: v, onSuccess: g, onExpire: T, onError: w, onBeforeInteractive: E, onAfterInteractive: i, onUnsupported: I, onTimeout: k, onLoadScript: W, id: te, style: re, as: ne = "div", injectScript: $ = true, rerenderOnCallbackChange: o = false, ...oe } = n, c = e.size, j = (0, import_react.useCallback)(() => typeof c > "u" ? {} : e.execution === "execute" ? f.invisible : e.appearance === "interaction-only" ? f.interactionOnly : f[c], [e.execution, c, e.appearance]), [ie, R] = (0, import_react.useState)(j()), u = (0, import_react.useRef)(null), [x, B] = (0, import_react.useState)(false), r = (0, import_react.useRef)(void 0), L = (0, import_react.useRef)(false), H = te || U, d = (0, import_react.useRef)({ onSuccess: g, onError: w, onExpire: T, onBeforeInteractive: E, onAfterInteractive: i, onUnsupported: I, onTimeout: k });
  (0, import_react.useEffect)(() => {
    o || (d.current = { onSuccess: g, onError: w, onExpire: T, onBeforeInteractive: E, onAfterInteractive: i, onUnsupported: I, onTimeout: k });
  });
  let O = (s == null ? void 0 : s.id) || b, A = z(O), V = (s == null ? void 0 : s.onLoadCallbackName) || P, se = e.appearance || "always", C = (0, import_react.useMemo)(() => ({ sitekey: m, action: e.action, cData: e.cData, theme: e.theme || "auto", language: e.language || "auto", tabindex: e.tabIndex, "response-field": e.responseField, "response-field-name": e.responseFieldName, size: G(c), retry: e.retry || "auto", "retry-interval": e.retryInterval || 8e3, "refresh-expired": e.refreshExpired || "auto", "refresh-timeout": e.refreshTimeout || "auto", execution: e.execution || "render", appearance: e.appearance || "always", "feedback-enabled": e.feedbackEnabled || true, callback: (t) => {
    var _a, _b;
    L.current = true, o ? g == null ? void 0 : g(t) : (_b = (_a = d.current).onSuccess) == null ? void 0 : _b.call(_a, t);
  }, "error-callback": o ? w : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onError) == null ? void 0 : _b.call(_a, ...t);
  }, "expired-callback": o ? T : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onExpire) == null ? void 0 : _b.call(_a, ...t);
  }, "before-interactive-callback": o ? E : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onBeforeInteractive) == null ? void 0 : _b.call(_a, ...t);
  }, "after-interactive-callback": o ? i : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onAfterInteractive) == null ? void 0 : _b.call(_a, ...t);
  }, "unsupported-callback": o ? I : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onUnsupported) == null ? void 0 : _b.call(_a, ...t);
  }, "timeout-callback": o ? k : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onTimeout) == null ? void 0 : _b.call(_a, ...t);
  } }), [e.action, e.appearance, e.cData, e.execution, e.language, e.refreshExpired, e.responseField, e.responseFieldName, e.retry, e.retryInterval, e.tabIndex, e.theme, e.feedbackEnabled, e.refreshTimeout, m, c, o, o ? g : null, o ? w : null, o ? T : null, o ? E : null, o ? i : null, o ? I : null, o ? k : null]), y = (0, import_react.useCallback)(() => typeof window < "u" && !!window.turnstile, []);
  return (0, import_react.useEffect)(function() {
    $ && !x && X({ onLoadCallbackName: V, scriptOptions: { ...s, id: O } });
  }, [$, x, s, O]), (0, import_react.useEffect)(function() {
    _ !== "ready" && we(V).then(() => B(true)).catch(console.error);
  }, []), (0, import_react.useEffect)(function() {
    if (!u.current || !x) return;
    let l = false;
    return (async () => {
      if (l || !u.current) return;
      let F = window.turnstile.render(u.current, C);
      r.current = F, r.current && (v == null ? void 0 : v(r.current));
    })(), () => {
      l = true, r.current && (window.turnstile.remove(r.current), L.current = false);
    };
  }, [H, x, C]), (0, import_react.useImperativeHandle)(a, () => {
    let { turnstile: t } = window;
    return { getResponse() {
      if (!(t == null ? void 0 : t.getResponse) || !r.current || !y()) {
        console.warn("Turnstile has not been loaded");
        return;
      }
      return t.getResponse(r.current);
    }, async getResponsePromise(l = 3e4, Y = 100) {
      return new Promise((F, N) => {
        let p, q = async () => {
          if (L.current && window.turnstile && r.current) try {
            let S = window.turnstile.getResponse(r.current);
            return p && clearTimeout(p), S ? F(S) : N(new Error("No response received"));
          } catch (S) {
            return p && clearTimeout(p), console.warn("Failed to get response", S), N(new Error("Failed to get response"));
          }
          p || (p = setTimeout(() => {
            p && clearTimeout(p), N(new Error("Timeout"));
          }, l)), await new Promise((S) => setTimeout(S, Y)), await q();
        };
        q();
      });
    }, reset() {
      if (!(t == null ? void 0 : t.reset) || !r.current || !y()) {
        console.warn("Turnstile has not been loaded");
        return;
      }
      e.execution === "execute" && R(f.invisible);
      try {
        L.current = false, t.reset(r.current);
      } catch (l) {
        console.warn(`Failed to reset Turnstile widget ${r}`, l);
      }
    }, remove() {
      if (!(t == null ? void 0 : t.remove) || !r.current || !y()) {
        console.warn("Turnstile has not been loaded");
        return;
      }
      R(f.invisible), L.current = false, t.remove(r.current), r.current = null;
    }, render() {
      if (!(t == null ? void 0 : t.render) || !u.current || !y() || r.current) {
        console.warn("Turnstile has not been loaded or container not found");
        return;
      }
      let l = t.render(u.current, C);
      return r.current = l, r.current && (v == null ? void 0 : v(r.current)), e.execution !== "execute" && R(c ? f[c] : {}), l;
    }, execute() {
      if (e.execution !== "execute") {
        console.warn('Execution mode is not set to "execute"');
        return;
      }
      if (!(t == null ? void 0 : t.execute) || !u.current || !r.current || !y()) {
        console.warn("Turnstile has not been loaded or container not found");
        return;
      }
      t.execute(u.current, C), R(c ? f[c] : {});
    }, isExpired() {
      return !(t == null ? void 0 : t.isExpired) || !r.current || !y() ? (console.warn("Turnstile has not been loaded"), false) : t.isExpired(r.current);
    } };
  }, [r, e.execution, c, C, u, y, x, v]), (0, import_react.useEffect)(() => {
    A && !x && window.turnstile && B(true);
  }, [x, A]), (0, import_react.useEffect)(() => {
    R(j());
  }, [e.execution, c, se]), (0, import_react.useEffect)(() => {
    !A || typeof W != "function" || W();
  }, [A]), (0, import_jsx_runtime2.jsx)(J, { ref: u, as: ne, id: H, style: { ...ie, ...re }, ...oe });
});
Ee.displayName = "Turnstile";
export {
  U as DEFAULT_CONTAINER_ID,
  P as DEFAULT_ONLOAD_NAME,
  b as DEFAULT_SCRIPT_ID,
  K as SCRIPT_URL,
  Ee as Turnstile
};
//# sourceMappingURL=@marsidev_react-turnstile.js.map

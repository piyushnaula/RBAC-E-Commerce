‚ö†Ô∏è CRITICAL INSTRUCTION FOR AI AGENT - INCREMENTAL DEVELOPMENT APPROACH:
DO NOT BUILD ENTIRE BACKEND FIRST! Instead, follow this workflow for EACH feature:

Build minimal backend API for ONE feature (simple, functional code - no complex logic initially)

Build basic frontend for that same feature (simple UI - just make it work, no fancy design)

Test if feature works end-to-end (verify functionality)

If working correctly ‚Üí Move to next feature

If issues found ‚Üí Fix before moving forward

ONLY after ALL features are implemented and working ‚Üí Polish UI professionally

Philosophy: Simple ‚Üí Functional ‚Üí Working ‚Üí Then Beautiful ‚ú®

üìã PROBLEM STATEMENT
[Keep same as before - no changes]

Context:
Small and medium e-commerce businesses struggle with secure multi-vendor marketplace platforms where different user roles (customers, merchants, support agents, finance team, platform admins) need controlled access to specific resources and operations.

Pain Points:

Authorization gaps: Merchants can accidentally access other vendors' data

Security vulnerabilities: No bot protection on critical flows

Compliance risks: No audit trails for sensitive operations

Payment security: Webhook spoofing risks

Resource abuse: API endpoints lack rate limiting

üí° SOLUTION
[Keep same as before]

Build a secure multi-vendor e-commerce platform with enterprise-grade RBAC where every API enforces permission checks and ownership validation with Razorpay payment integration.‚Äã

‚ú® FEATURES & TECH STACK
[Keep same as before - Features list and Tech Stack sections remain unchanged]

üéØ BUILD SEQUENCE - INCREMENTAL FEATURE-BY-FEATURE APPROACH
‚ö° IMPORTANT: For each feature below:
Write simple, minimal backend code (no over-engineering)

Write basic frontend UI (no fancy styling, just functional HTML/forms)

Test thoroughly with Postman + browser

Verify everything works before moving to next feature

Keep UI plain and simple - professional styling comes at the END

ITERATION 1: Project Setup + Basic Authentication (Days 1-3)
Backend Tasks:
bash
# Initialize project
npm init -y
npm install express typescript prisma @prisma/client bcryptjs jsonwebtoken zod dotenv cors

# Setup Prisma
npx prisma init
Create these files (MINIMAL CODE ONLY):

prisma/schema.prisma - Only User table for now

text
model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String   @map("password_hash")
  createdAt    DateTime @default(now())
  
  @@map("users")
}
src/index.ts - Minimal Express server

src/modules/auth/auth.routes.ts - Just /signup and /login endpoints

src/utils/jwt.util.ts - Simple JWT sign/verify functions

src/utils/hash.util.ts - bcrypt hash/compare

APIs to create:

POST /api/v1/auth/signup - Takes email + password, hashes password, saves to DB

POST /api/v1/auth/login - Checks credentials, returns JWT token

Frontend Tasks:
Create BASIC React app:

bash
npm create vite@latest frontend -- --template react-ts
cd frontend && npm install axios react-router-dom
Create these pages (SIMPLE HTML FORMS ONLY):

Login.tsx - Email/password input + submit button (NO STYLING)

Signup.tsx - Email/password input + submit button (NO STYLING)

Basic routing between login/signup

UI Example (KEEP IT THIS SIMPLE):

tsx
// Login.tsx - Version 1.0 (BASIC)
export default function Login() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  const handleLogin = async () => {
    const res = await axios.post('/api/v1/auth/login', { email, password });
    localStorage.setItem('token', res.data.token);
    alert('Login successful!');
  };
  
  return (
    <div>
      <h1>Login</h1>
      <input value={email} onChange={e => setEmail(e.target.value)} />
      <input type="password" value={password} onChange={e => setPassword(e.target.value)} />
      <button onClick={handleLogin}>Login</button>
    </div>
  );
}
Testing Checklist:
‚úÖ Can signup with email/password

‚úÖ Can login and get JWT token

‚úÖ Token stored in localStorage

‚úÖ Login redirects to home page

‚úã STOP HERE - Do NOT proceed until this works perfectly!

ITERATION 2: RBAC Foundation + User Profile (Days 4-6)
Backend Tasks:
Update prisma/schema.prisma: Add Role, Permission, UserRole tables (from full schema above)

Create these files (SIMPLE CODE):

src/middleware/auth.middleware.ts - Verify JWT, attach user to req

src/middleware/rbac.middleware.ts - Check if user has permission

src/modules/rbac/rbac.routes.ts - Role assignment endpoints

prisma/seed.ts - Seed 3 basic roles: Customer, Merchant, Admin

APIs to create:

GET /api/v1/users/me - Get current user with roles

POST /api/v1/rbac/assign-role - Assign role to user (Admin only)

Frontend Tasks:
Create BASIC pages:

Profile.tsx - Show user email + roles (plain text display)

AdminPanel.tsx - List users + button to assign roles (simple dropdown)

Add protected routes (if no token, redirect to login)

Testing Checklist:
‚úÖ Login shows user profile with roles

‚úÖ Admin can assign "Merchant" role to user

‚úÖ Non-admin cannot access admin panel

‚úÖ RBAC middleware blocks unauthorized requests

‚úã STOP HERE - Verify RBAC works before continuing!

ITERATION 3: Vendor Registration + Store Setup (Days 7-9)
Backend Tasks:
Update Prisma: Add Vendor, Store tables

Create:

src/modules/vendors/vendor.routes.ts

POST /api/v1/vendors - Create vendor (requires Merchant role)

GET /api/v1/vendors/me - Get own vendor info

Add ownership check in vendor.service.ts (user can only see their vendor data)

Frontend Tasks:
Create:

VendorRegistration.tsx - Form with legal name, business type (basic input fields)

VendorDashboard.tsx - Show vendor info (plain text)

Testing Checklist:
‚úÖ User with "Merchant" role can create vendor

‚úÖ User with "Customer" role gets 403 error

‚úÖ Merchant can only see their own vendor data

‚úÖ Ownership check prevents accessing other vendors

‚úã STOP HERE!

ITERATION 4: Product Management (Days 10-13)
Backend Tasks:
Update Prisma: Add Product, ProductVariant, ProductImage, Inventory tables

Create:

src/modules/products/product.routes.ts

POST /api/v1/products - Create product (ownership: only vendor's store)

GET /api/v1/products - List all products (public)

PATCH /api/v1/products/:id - Update product (ownership check!)

DELETE /api/v1/products/:id - Delete product (ownership check!)

CRITICAL: Add ownership validation:

typescript
// Check if product belongs to current vendor
const product = await prisma.product.findFirst({
  where: { id, store: { vendor: { userId: req.user.id } } }
});
if (!product) throw new ForbiddenError();
Frontend Tasks:
Create BASIC pages:

ProductList.tsx - Show all products (simple table or list)

ProductForm.tsx - Add/Edit product (basic input fields: title, price, SKU)

VendorProducts.tsx - Vendor's own products with Edit/Delete buttons

Testing Checklist:
‚úÖ Vendor can create product for their store

‚úÖ Vendor can edit/delete ONLY their products

‚úÖ Trying to edit other vendor's product returns 403

‚úÖ Public can view all products

‚úã STOP HERE!

ITERATION 5: Shopping Cart + Checkout (Days 14-17)
Backend Tasks:
Update Prisma: Add Cart, CartItem, Order, OrderItem, Customer, Address tables

Create:

src/modules/cart/cart.routes.ts

POST /api/v1/cart/items - Add item to cart

GET /api/v1/cart - Get current user's cart

DELETE /api/v1/cart/items/:id - Remove item

src/modules/orders/order.routes.ts

POST /api/v1/orders - Create order from cart

Frontend Tasks:
Create BASIC pages:

Cart.tsx - Show cart items (simple list) + Remove buttons

Checkout.tsx - Basic form: Address input + "Place Order" button

NO payment integration yet - just create order with PENDING status

Testing Checklist:
‚úÖ Can add products to cart

‚úÖ Can remove items from cart

‚úÖ Can place order (order created in DB with PENDING status)

‚úÖ Cart clears after order placed

‚úã STOP HERE!

ITERATION 6: Razorpay Payment Integration (Days 18-20)
Backend Tasks:
Install Razorpay:

bash
npm install razorpay
Update Prisma: Add Payment table with razorpay fields

Create:

src/config/razorpay.ts - Initialize Razorpay instance

src/modules/payments/payment.routes.ts

POST /api/v1/payments/create-order - Create Razorpay order‚Äã

POST /api/v1/payments/verify-payment - Verify signature‚Äã

POST /api/v1/payments/webhook - Handle Razorpay webhooks‚Äã

Implement signature verification (CRITICAL):‚Äã

typescript
const crypto = require('crypto');
const expectedSignature = crypto
  .createHmac('sha256', process.env.RAZORPAY_KEY_SECRET)
  .update(`${razorpay_order_id}|${razorpay_payment_id}`)
  .digest('hex');

if (expectedSignature !== razorpay_signature) {
  throw new Error('Invalid signature');
}
Frontend Tasks:
Add Razorpay script to index.html:‚Äã

xml
<script src="https://checkout.razorpay.com/v1/checkout.js"></script>
Update:

Checkout.tsx - Add "Pay Now" button that opens Razorpay modal

hooks/useRazorpay.ts - Handle Razorpay checkout

KEEP IT SIMPLE:

tsx
const handlePayment = async () => {
  // 1. Create Razorpay order
  const { data } = await api.post('/payments/create-order', { orderId, amount });
  
  // 2. Open Razorpay
  const razorpay = new window.Razorpay({
    key: data.key,
    order_id: data.orderId,
    handler: async (response) => {
      // 3. Verify payment
      await api.post('/payments/verify-payment', response);
      alert('Payment successful!');
    }
  });
  razorpay.open();
};
Testing Checklist:
‚úÖ Razorpay modal opens on "Pay Now"

‚úÖ Test payment with Razorpay test cards

‚úÖ Payment signature verified correctly

‚úÖ Order status changes to PAID after payment

‚úÖ Webhook receives payment events

‚úã STOP HERE - Payment is critical, must work perfectly!

ITERATION 7: Order Management (Days 21-23)
Backend Tasks:
Create:

src/modules/orders/order.routes.ts (extend)

GET /api/v1/orders - List orders (customer sees own, vendor sees their store orders)

GET /api/v1/orders/:id - Get order details (ownership check)

PATCH /api/v1/orders/:id/status - Update status (vendor only for their orders)

Ownership logic:

typescript
// Vendor sees only orders containing their products
const orders = await prisma.order.findMany({
  where: {
    items: {
      some: { vendorId: currentVendor.id }
    }
  }
});
Frontend Tasks:
Create:

MyOrders.tsx - Customer's order list (simple table)

VendorOrders.tsx - Vendor's orders + "Mark as Shipped" button

OrderDetails.tsx - Show order items, status, payment info

Testing Checklist:
‚úÖ Customer sees only their orders

‚úÖ Vendor sees only orders with their products

‚úÖ Vendor can update order status

‚úÖ Customer cannot update order status

‚úã STOP HERE!

ITERATION 8: Refund Management + Admin Panel (Days 24-26)
Backend Tasks:
Update Prisma: Add Refund, AuditLog tables

Create:

src/modules/refunds/refund.routes.ts

POST /api/v1/refunds - Request refund

POST /api/v1/refunds/:id/approve - Approve (Finance role only)

Log refund approval to audit_logs table

Frontend Tasks:
Create BASIC pages:

RequestRefund.tsx - Form to request refund

AdminRefunds.tsx - List pending refunds + Approve button (Finance only)

AuditLogs.tsx - Show audit log table (Admin only)

Testing Checklist:
‚úÖ Customer can request refund

‚úÖ Finance user can approve refund

‚úÖ Merchant cannot approve refunds (gets 403)

‚úÖ Refund approval logged to audit_logs

‚úã STOP HERE!

ITERATION 9: Security Hardening (Days 27-28)
Backend Tasks:
Add:

Rate limiting:‚Äã

bash
npm install express-rate-limit
typescript
import rateLimit from 'express-rate-limit';

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5 // 5 requests per IP
});

app.use('/api/v1/auth/login', loginLimiter);
reCAPTCHA on signup/login:

typescript
// Verify reCAPTCHA token
const recaptchaRes = await axios.post(
  `https://www.google.com/recaptcha/api/siteverify`,
  null,
  { params: { secret: process.env.RECAPTCHA_SECRET, response: token } }
);
Helmet.js for security headers:

bash
npm install helmet
Frontend Tasks:
Add:

<ReCAPTCHA> component to Login/Signup forms

Store JWT in memory instead of localStorage (for XSS protection)

Add CSRF protection

Testing Checklist:
‚úÖ Login fails after 5 wrong attempts

‚úÖ reCAPTCHA blocks bot signups

‚úÖ Security headers present (check with browser dev tools)

‚úã STOP HERE!

ITERATION 10: Settlement Module (Optional - Days 29-30)
[Similar incremental approach for vendor settlements]

üé® FINAL PHASE: UI/UX POLISH (Days 31-35)
‚ö†Ô∏è DO THIS ONLY AFTER ALL FEATURES ARE WORKING!

Now that everything works functionally, make it beautiful:

Backend: NO CHANGES NEEDED
Frontend Polish Tasks:
Replace basic HTML with professional components:

Install Shadcn/ui: npx shadcn-ui@latest init

Replace <input> with <Input> component

Replace <button> with <Button> component

Add proper form validation with React Hook Form

Add professional styling:

Create consistent color scheme (primary, secondary, accent)

Add Tailwind classes for spacing, shadows, borders

Add hover effects, transitions, animations

Make responsive (mobile-first design)

Improve UX:

Add loading spinners

Add success/error toast notifications

Add empty states ("No products yet")

Add skeleton loaders

Add confirmation modals ("Are you sure you want to delete?")

Dashboard improvements:

Add charts for sales analytics (Recharts)

Add data tables with sorting/filtering

Add breadcrumbs for navigation

Add sidebar with icons

Polish specific pages:

Login/Signup: Professional cards with gradients

Product List: Grid layout with hover effects

Checkout: Multi-step form with progress indicator

Vendor Dashboard: Cards with stats, charts

Admin Panel: Professional tables, badges for status

Example: Login Before vs After

tsx
// BEFORE (Iteration 1) - BASIC
<div>
  <h1>Login</h1>
  <input value={email} onChange={e => setEmail(e.target.value)} />
  <input type="password" value={password} onChange={e => setPassword(e.target.value)} />
  <button onClick={handleLogin}>Login</button>
</div>

// AFTER (Final Polish) - PROFESSIONAL
<div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-100">
  <Card className="w-full max-w-md p-8 shadow-2xl">
    <CardHeader>
      <CardTitle className="text-3xl font-bold text-center">Welcome Back</CardTitle>
      <CardDescription className="text-center">Sign in to your account</CardDescription>
    </CardHeader>
    <CardContent>
      <Form {...form}>
        <FormField name="email" render={({ field }) => (
          <FormItem>
            <FormLabel>Email</FormLabel>
            <FormControl>
              <Input placeholder="you@example.com" {...field} className="h-12" />
            </FormControl>
            <FormMessage />
          </FormItem>
        )} />
        
        <FormField name="password" render={({ field }) => (
          <FormItem>
            <FormLabel>Password</FormLabel>
            <FormControl>
              <Input type="password" {...field} className="h-12" />
            </FormControl>
            <FormMessage />
          </FormItem>
        )} />
        
        <Button 
          onClick={handleLogin} 
          className="w-full h-12 mt-6 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700"
          disabled={isLoading}
        >
          {isLoading ? <Spinner /> : 'Sign In'}
        </Button>
      </Form>
    </CardContent>
  </Card>
</div>
üìù FINAL NOTES FOR AI AGENT
Golden Rules:
‚úÖ DO: Build one feature at a time, test it, then move forward

‚úÖ DO: Keep code simple and minimal initially

‚úÖ DO: Make functionality work FIRST, beauty comes LAST

‚úÖ DO: Test thoroughly after each iteration

‚ùå DON'T: Write complex/over-engineered code initially

‚ùå DON'T: Add fancy UI before features work

‚ùå DON'T: Move to next feature if current one has bugs

‚ùå DON'T: Skip testing - it will cause problems later

Success Criteria (Check after EACH iteration):
‚úÖ Feature works end-to-end (backend ‚Üí frontend ‚Üí database)

‚úÖ No errors in console (browser + terminal)

‚úÖ API returns correct data

‚úÖ RBAC/ownership checks working

‚úÖ Code is simple and readable

When to Polish UI:
‚è±Ô∏è NOT during Iterations 1-9 (focus on functionality)

‚úÖ ONLY in Final Phase (after everything works)

Testing Mantra:
"If you can't test it, you can't ship it. If it doesn't work simply, it won't work complexly."